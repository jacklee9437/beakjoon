from sys import stdin
input = stdin.readline

A, B, C = map(int,input().split())

ans = initRemain = A%C

if B <= C :  
    for i in range(1, B) :
        ans = pow(ans, initRemain) % C
    print(ans)
else :
    remains = [initRemain]
    remain = initRemain
    for i in range(C-1) :
        remain = remain * initRemain % C
        remains.append(remain)
    print(remain[(B-1)%C])
    

'''
🤔 문제정의를 잘 하자 🤔

입력 : 자연수 A, 곱하는 횟수 B, 나누는 수 C
출력 : 나머지

찾아야하는 값 : A를 B번 곱하고 C로나눈 나머지 출력
알고리즘 : 분할정복

-----
너무 큰 수에서 시간초과가 걸려서 단순한 방법으로는 안됨...
어떻게 분할 해서 정복해야할까...

나머지가 규칙적으로 돌아갈텐데, 그 규칙대로 배열 만들어놓고 찾아다 답만 내보낸다? 
- 나누는 수 조차도 너무 커서 그 경우를 만드는것도 한세월임
- 규칙을 이용하려는 것 자체가 무리가 있을듯..

아예 계산을 단순화할 수 있는 방법이 있을까?
나누는수인 C는 건드릴 방법이 없어보임,,
A를 간단하게 만드는 방법?
- A를 C로 나누면 몫은 어차피 나누어 떨어진 값이어서 다시 곱해도 계속 나누어 떨어져 사라짐. 따라서 A를 반복적으로 곱할때 계속 A로 구하는게 아니라 나머지에 A 곱한 값으로 구할 수 있음.
- 애초에 A를 계속 반복해서 곱하는데, A의 몫은 계속해서 나누어 떨어지는 부분이기 때문에 A에서 빼줘도 됨. 즉, 초반에 구한 나머지값을 계속 곱해주면 되는 것,,
B를 간단하게?
- B가 C보다 작을때는 그냥 구하면 되지만, 그 이후에는 나머지 규칙이 반복되기 때문에 그거로 구하는게 낫지 않을까?

그래도 틀림... ㅠㅠ


실패원인
- 계산과정에서 숫자가 크고작음의 문제가 아니라, 계산 횟수가 너무 많아서의 문제였음. 
- 계산과정에서 숫자를 작게만들 방법은 생각했지만, 계산 횟수를 줄일 방법을 생각하지 못했음 -> 컴퓨터 연산에 대한 이해 부족,,
- 즉 *나 2제곱이나 속도가 비슷한데, 시간에 문제가 되는건 계산 횟수임.
- **** 는 연산이 4번이지만, (**)^2 는 연산이 3번으로 줄어들어 속도가 줄어든다는 의미.



-----

'''